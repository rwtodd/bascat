\input texinfo
@include version.texi
@settitle BasCat 1.0
@setfilename bascat.info

@dircategory General Commands
@direntry
* bascat: (bascat).   Decode GW-BASiC/BASICA files.
@end direntry

@copying

Copyright @copyright{} 2018 Richard Todd
@end copying

@titlepage
@title BasCat
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of the contents at the beginning.
@contents

@ifnottex
@node Top
@top BasCat 

This manual is for BasCat
(version @value{VERSION}, @value{UPDATED}).
@end ifnottex

BasCat reads @file{.BAS} files saved in the default binary format by
@sc{GW-BASIC} and @sc{BASICA}, outputting plain text. This allows the code to
be studied or ported without needing to run the interpreters in a virtual
machine.  Run the program like so: 

@example
bascat @file{<filename>}
@end example

It was possible to save tokenized files encrypted, though I don't have any
actual examples of encrypted files. The program will attempt to decode an
encrypted file via an algorithm I found in the 
@uref{http://sourceforge.net/p/pcbasic/wiki/Home/, PC-BASIC project}.
However, since I don't have any protected @file{.BAS} files, so I have not
tested that code.

A reference for the @sc{GW-BASIC} tokens can be found here: 
@uref{http://chebucto.ns.ca/~af380/GW-BASIC-tokens.html}.

@menu
* Win32 Port Notes::  Description of needed changes.
@end menu

@node Win32 Port Notes

I also made a win32 version, which only needed changes for the @code{mmap} part
in @code{load_buffer}.  It's not important enough to me to put in @code{#ifdef}s or
otherwise make the project cross-platform, but I saved the modified function
here for reference.

Here is the modified function:

@verbatim
/* Read the first byte of FNAME, and decrypt the file
 * if necessary.  Then, return the unencrypted bytes.
 * N.B: we just forget about the fd, and never close the file
 * or unmap the memory since this program exits right after
 * finishing anyway. */
static bool load_buffer(gwbas_data *const b, LPCWSTR fname) {
    b->index = 1;
    HANDLE h = CreateFile(fname, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (h == INVALID_HANDLE_VALUE) return false;
    DWORD sz = GetFileSize(h, NULL);
    b->len = sz;
    HANDLE hmap = CreateFileMapping(h, NULL, PAGE_READONLY, 0, sz, NULL);
    if (hmap == INVALID_HANDLE_VALUE) return false;
    b->buffer = (uint8_t*)MapViewOfFile(hmap, FILE_MAP_COPY, 0, 0, b->len);
    if (b->buffer == NULL) {
        return false;
    }
    
    /* decrypt b if necessary, and detect a bad 1st byte */
    switch (b->buffer[0]) {
    case 0xff: break;
    case 0xfe: decrypt_buffer(b->buffer, b->len);
        break;
    default:   return false;
    }
    return true;
}
@end verbatim

@bye
